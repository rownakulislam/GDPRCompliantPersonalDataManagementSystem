{"ast":null,"code":"export function isStartable(obj) {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function';\n}\nexport async function start(...objs) {\n  const startables = [];\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj);\n    }\n  }\n  await Promise.all(startables.map(async s => {\n    if (s.beforeStart != null) {\n      await s.beforeStart();\n    }\n  }));\n  await Promise.all(startables.map(async s => {\n    await s.start();\n  }));\n  await Promise.all(startables.map(async s => {\n    if (s.afterStart != null) {\n      await s.afterStart();\n    }\n  }));\n}\nexport async function stop(...objs) {\n  const startables = [];\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj);\n    }\n  }\n  await Promise.all(startables.map(async s => {\n    if (s.beforeStop != null) {\n      await s.beforeStop();\n    }\n  }));\n  await Promise.all(startables.map(async s => {\n    await s.stop();\n  }));\n  await Promise.all(startables.map(async s => {\n    if (s.afterStop != null) {\n      await s.afterStop();\n    }\n  }));\n}","map":{"version":3,"names":["isStartable","obj","start","stop","objs","startables","push","Promise","all","map","s","beforeStart","afterStart","beforeStop","afterStop"],"sources":["C:\\shibu2\\Ethereum-DappV2\\node_modules\\@libp2p\\interface\\src\\startable.ts"],"sourcesContent":["/**\n * Implemented by components that have a lifecycle\n */\nexport interface Startable {\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?(): void | Promise<void>\n}\n\nexport function isStartable (obj: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n"],"mappings":"AA+CA,OAAM,SAAUA,WAAWA,CAAEC,GAAQ;EACnC,OAAOA,GAAG,IAAI,IAAI,IAAI,OAAOA,GAAG,CAACC,KAAK,KAAK,UAAU,IAAI,OAAOD,GAAG,CAACE,IAAI,KAAK,UAAU;AACzF;AAEA,OAAO,eAAeD,KAAKA,CAAE,GAAGE,IAAW;EACzC,MAAMC,UAAU,GAAgB,EAAE;EAElC,KAAK,MAAMJ,GAAG,IAAIG,IAAI,EAAE;IACtB,IAAIJ,WAAW,CAACC,GAAG,CAAC,EAAE;MACpBI,UAAU,CAACC,IAAI,CAACL,GAAG,CAAC;IACtB;EACF;EAEA,MAAMM,OAAO,CAACC,GAAG,CACfH,UAAU,CAACI,GAAG,CAAC,MAAMC,CAAC,IAAG;IACvB,IAAIA,CAAC,CAACC,WAAW,IAAI,IAAI,EAAE;MACzB,MAAMD,CAAC,CAACC,WAAW,EAAE;IACvB;EACF,CAAC,CAAC,CACH;EAED,MAAMJ,OAAO,CAACC,GAAG,CACfH,UAAU,CAACI,GAAG,CAAC,MAAMC,CAAC,IAAG;IACvB,MAAMA,CAAC,CAACR,KAAK,EAAE;EACjB,CAAC,CAAC,CACH;EAED,MAAMK,OAAO,CAACC,GAAG,CACfH,UAAU,CAACI,GAAG,CAAC,MAAMC,CAAC,IAAG;IACvB,IAAIA,CAAC,CAACE,UAAU,IAAI,IAAI,EAAE;MACxB,MAAMF,CAAC,CAACE,UAAU,EAAE;IACtB;EACF,CAAC,CAAC,CACH;AACH;AAEA,OAAO,eAAeT,IAAIA,CAAE,GAAGC,IAAW;EACxC,MAAMC,UAAU,GAAgB,EAAE;EAElC,KAAK,MAAMJ,GAAG,IAAIG,IAAI,EAAE;IACtB,IAAIJ,WAAW,CAACC,GAAG,CAAC,EAAE;MACpBI,UAAU,CAACC,IAAI,CAACL,GAAG,CAAC;IACtB;EACF;EAEA,MAAMM,OAAO,CAACC,GAAG,CACfH,UAAU,CAACI,GAAG,CAAC,MAAMC,CAAC,IAAG;IACvB,IAAIA,CAAC,CAACG,UAAU,IAAI,IAAI,EAAE;MACxB,MAAMH,CAAC,CAACG,UAAU,EAAE;IACtB;EACF,CAAC,CAAC,CACH;EAED,MAAMN,OAAO,CAACC,GAAG,CACfH,UAAU,CAACI,GAAG,CAAC,MAAMC,CAAC,IAAG;IACvB,MAAMA,CAAC,CAACP,IAAI,EAAE;EAChB,CAAC,CAAC,CACH;EAED,MAAMI,OAAO,CAACC,GAAG,CACfH,UAAU,CAACI,GAAG,CAAC,MAAMC,CAAC,IAAG;IACvB,IAAIA,CAAC,CAACI,SAAS,IAAI,IAAI,EAAE;MACvB,MAAMJ,CAAC,CAACI,SAAS,EAAE;IACrB;EACF,CAAC,CAAC,CACH;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}