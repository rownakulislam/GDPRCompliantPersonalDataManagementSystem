{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\thesis_project_start\\Ethereum-DappV2\\node_modules\\@libp2p\\interface\\src\\connection-gater\\index.ts"],"sourcesContent":["import type { MultiaddrConnection } from '../connection/index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface ConnectionGater {\n  /**\n   * denyDialPeer tests whether we're permitted to Dial the\n   * specified peer.\n   *\n   * This is called by the dialer.connectToPeer implementation before\n   * dialling a peer.\n   *\n   * Return true to prevent dialing the passed peer.\n   */\n  denyDialPeer?(peerId: PeerId): Promise<boolean>\n\n  /**\n   * denyDialMultiaddr tests whether we're permitted to dial the specified\n   * multiaddr.\n   *\n   * This is called by the connection manager - if the peer id of the remote\n   * node is known it will be present in the multiaddr.\n   *\n   * Return true to prevent dialing the passed peer on the passed multiaddr.\n   */\n  denyDialMultiaddr?(multiaddr: Multiaddr): Promise<boolean>\n\n  /**\n   * denyInboundConnection tests whether an incipient inbound connection is allowed.\n   *\n   * This is called by the upgrader, or by the transport directly (e.g. QUIC,\n   * Bluetooth), straight after it has accepted a connection from its socket.\n   *\n   * Return true to deny the incoming passed connection.\n   */\n  denyInboundConnection?(maConn: MultiaddrConnection): Promise<boolean>\n\n  /**\n   * denyOutboundConnection tests whether an incipient outbound connection is allowed.\n   *\n   * This is called by the upgrader, or by the transport directly (e.g. QUIC,\n   * Bluetooth), straight after it has created a connection with its socket.\n   *\n   * Return true to deny the incoming passed connection.\n   */\n  denyOutboundConnection?(peerId: PeerId, maConn: MultiaddrConnection): Promise<boolean>\n\n  /**\n   * denyInboundEncryptedConnection tests whether a given connection, now encrypted,\n   * is allowed.\n   *\n   * This is called by the upgrader, after it has performed the security\n   * handshake, and before it negotiates the muxer, or by the directly by the\n   * transport, at the exact same checkpoint.\n   *\n   * Return true to deny the passed secured connection.\n   */\n  denyInboundEncryptedConnection?(peerId: PeerId, maConn: MultiaddrConnection): Promise<boolean>\n\n  /**\n   * denyOutboundEncryptedConnection tests whether a given connection, now encrypted,\n   * is allowed.\n   *\n   * This is called by the upgrader, after it has performed the security\n   * handshake, and before it negotiates the muxer, or by the directly by the\n   * transport, at the exact same checkpoint.\n   *\n   * Return true to deny the passed secured connection.\n   */\n  denyOutboundEncryptedConnection?(peerId: PeerId, maConn: MultiaddrConnection): Promise<boolean>\n\n  /**\n   * denyInboundUpgradedConnection tests whether a fully capable connection is allowed.\n   *\n   * This is called after encryption has been negotiated and the connection has been\n   * multiplexed, if a multiplexer is configured.\n   *\n   * Return true to deny the passed upgraded connection.\n   */\n  denyInboundUpgradedConnection?(peerId: PeerId, maConn: MultiaddrConnection): Promise<boolean>\n\n  /**\n   * denyOutboundUpgradedConnection tests whether a fully capable connection is allowed.\n   *\n   * This is called after encryption has been negotiated and the connection has been\n   * multiplexed, if a multiplexer is configured.\n   *\n   * Return true to deny the passed upgraded connection.\n   */\n  denyOutboundUpgradedConnection?(peerId: PeerId, maConn: MultiaddrConnection): Promise<boolean>\n\n  /**\n   * denyInboundRelayReservation tests whether a remote peer is allowed make a\n   * relay reservation on this node.\n   *\n   * Return true to deny the relay reservation.\n   */\n  denyInboundRelayReservation?(source: PeerId): Promise<boolean>\n\n  /**\n   * denyOutboundRelayedConnection tests whether a remote peer is allowed to open a relayed\n   * connection to the destination node.\n   *\n   * This is invoked on the relay server when a source client with a reservation instructs\n   * the server to relay a connection to a destination peer.\n   *\n   * Return true to deny the relayed connection.\n   */\n  denyOutboundRelayedConnection?(source: PeerId, destination: PeerId): Promise<boolean>\n\n  /**\n   * denyInboundRelayedConnection tests whether a remote peer is allowed to open a relayed\n   * connection to this node.\n   *\n   * This is invoked on the relay client when a remote relay has received an instruction to\n   * relay a connection to the client.\n   *\n   * Return true to deny the relayed connection.\n   */\n  denyInboundRelayedConnection?(relay: PeerId, remotePeer: PeerId): Promise<boolean>\n\n  /**\n   * Used by the address book to filter passed addresses.\n   *\n   * Return true to allow storing the passed multiaddr for the passed peer.\n   */\n  filterMultiaddrForPeer?(peer: PeerId, multiaddr: Multiaddr): Promise<boolean>\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}