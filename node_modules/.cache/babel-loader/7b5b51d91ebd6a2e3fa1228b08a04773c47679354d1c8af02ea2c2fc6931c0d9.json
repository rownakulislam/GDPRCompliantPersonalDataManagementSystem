{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\shibu2\\Ethereum-DappV2\\node_modules\\@libp2p\\interface\\src\\peer-store\\index.ts"],"sourcesContent":["import type { PeerId } from '../peer-id/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * A multiaddr with an optional flag that indicates if its trustworthy\n */\nexport interface Address {\n  /**\n   * Peer multiaddr\n   */\n  multiaddr: Multiaddr\n\n  /**\n   * Obtained from a signed peer record\n   */\n  isCertified: boolean\n}\n\n/**\n * Data stored in the peer store about peers\n */\nexport interface Peer {\n  /**\n   * Peer's peer-id instance\n   */\n  id: PeerId\n\n  /**\n   * Peer's addresses containing a list of multiaddrs and a isCertified field\n   * indicating if the address was loaded from a signed peer record or not\n   */\n  addresses: Address[]\n\n  /**\n   * Peer's supported protocols\n   */\n  protocols: string[]\n\n  /**\n   * Peer's metadata map\n   */\n  metadata: Map<string, Uint8Array>\n\n  /**\n   * Tags a peer has\n   */\n  tags: Map<string, Tag>\n\n  /**\n   * The last peer record envelope received\n   */\n  peerRecordEnvelope?: Uint8Array\n}\n\n/**\n * Peer data used to update the peer store\n */\nexport interface PeerData {\n  /**\n   * Peer's addresses containing its multiaddrs and metadata - multiaddrs\n   * passed here can be treated as certified if the `isCertifed` value is\n   * set to true.\n   *\n   * If both addresses and multiaddrs are specified they will be merged\n   * together with entries in addresses taking precedence.\n   */\n  addresses?: Address[]\n\n  /**\n   * Peer's multiaddrs - any multiaddrs passed here will be treated as\n   * uncertified.\n   *\n   * If both addresses and multiaddrs are specified they will be merged\n   * together with entries in addresses taking precedence.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Peer's supported protocols\n   */\n  protocols?: string[]\n\n  /**\n   * Peer's metadata map. When merging pass undefined as values to remove metadata.\n   */\n  metadata?: Map<string, Uint8Array | undefined> | Record<string, Uint8Array | undefined>\n\n  /**\n   * Peer tags. When merging pass undefined as values to remove tags.\n   */\n  tags?: Map<string, TagOptions | undefined> | Record<string, TagOptions | undefined>\n\n  /**\n   * If this Peer has an RSA key, it's public key can be set with this property\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * The last peer record envelope received\n   */\n  peerRecordEnvelope?: Uint8Array\n}\n\nexport interface TagOptions {\n  /**\n   * An optional tag value (1-100)\n   */\n  value?: number\n\n  /**\n   * An optional duration in ms after which the tag will expire\n   */\n  ttl?: number\n}\n\nexport interface Tag {\n  /**\n   * The tag value\n   */\n  value: number\n}\n\n/**\n * A predicate by which to filter lists of peers\n */\nexport interface PeerQueryFilter { (peer: Peer): boolean }\n\n/**\n * A predicate by which to sort lists of peers\n */\nexport interface PeerQueryOrder { (a: Peer, b: Peer): -1 | 0 | 1 }\n\n/**\n * A query for getting lists of peers\n */\nexport interface PeerQuery {\n  filters?: PeerQueryFilter[]\n  orders?: PeerQueryOrder[]\n  limit?: number\n  offset?: number\n}\n\nexport interface PeerStore {\n  /**\n   * Loop over every peer - the looping is async because we read from a\n   * datastore but the peer operation is sync, this is to prevent\n   * long-lived peer operations causing deadlocks over the datastore\n   * which can happen if they try to access the peer store during the\n   * loop\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.forEach(peer => {\n   *   // ...\n   * })\n   * ```\n   */\n  forEach(fn: (peer: Peer) => void, query?: PeerQuery): Promise<void>\n\n  /**\n   * Returns all peers in the peer store.\n   *\n   * @example\n   *\n   * ```js\n   * for (const peer of await peerStore.all()) {\n   *   // ...\n   * }\n   * ```\n   */\n  all(query?: PeerQuery): Promise<Peer[]>\n\n  /**\n   * Delete all data stored for the passed peer\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.addressBook.set(peerId, multiaddrs)\n   * await peerStore.addressBook.get(peerId)\n   * // multiaddrs[]\n   *\n   * await peerStore.delete(peerId)\n   *\n   * await peerStore.addressBook.get(peerId)\n   * // []\n   * ```\n   */\n  delete(peerId: PeerId): Promise<void>\n\n  /**\n   * Returns true if the passed PeerId is in the peer store\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.has(peerId)\n   * // false\n   * await peerStore.addressBook.add(peerId, multiaddrs)\n   * await peerStore.has(peerId)\n   * // true\n   * ```\n   */\n  has(peerId: PeerId): Promise<boolean>\n\n  /**\n   * Returns all data stored for the passed PeerId\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await peerStore.get(peerId)\n   * // { .. }\n   * ```\n   */\n  get(peerId: PeerId): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, overwriting any existing data\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.save(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  save(id: PeerId, data: PeerData): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, overwriting only the passed fields\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.patch(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  patch(id: PeerId, data: PeerData): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, deeply merging any existing data.\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.merge(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  merge(id: PeerId, data: PeerData): Promise<Peer>\n\n  /**\n   * Unmarshal and verify a signed peer record, extract the multiaddrs and\n   * overwrite the stored addresses for the peer.\n   *\n   * Optionally pass an expected PeerId to verify that the peer record was\n   * signed by that peer.\n   *\n   * @example\n   *\n   * ```js\n   * await peerStore.consumePeerRecord(buf, expectedPeer)\n   * ```\n   */\n  consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean>\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}